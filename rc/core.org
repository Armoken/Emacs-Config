#+TITLE: Core
#+OPTIONS: toc:nil num:nil ^:nil

Core settings for editor

* Configuration
** Reload configuration
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/reload-configuration ()
         "Reload configuration starting from ~/.emacs.d/init.el"
         (interactive)
         (load-file (ayrc/expand-config-path "./init.el")))

     (defun ayrc/reload-current-config ()
         (interactive)
         (let ((filename (buffer-file-name)))
             (if (string-equal (file-name-extension filename) "org")
                     (org-babel-load-file filename)
                 (load-file filename))))
   #+END_SRC

** Bookmarks
   #+BEGIN_SRC emacs-lisp
     (setq bookmark-save-flag 1)
   #+END_SRC

** [[Https://github.com/10sr/switch-buffer-functions-el][Hook Run When Current Buffer Changed]]
   #+BEGIN_SRC emacs-lisp
     (use-package switch-buffer-functions
         :ensure t)
   #+END_SRC

** Backups in /tmp
   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist
           `((".*" . ,temporary-file-directory)))
     (setq auto-save-file-name-transforms
           `((".*" ,temporary-file-directory t)))
   #+END_SRC

** [[https://www.emacswiki.org/emacs/Desktop][Session saving]]
   Save partial status of Emacs when killed

   #+BEGIN_SRC emacs-lisp
     (use-package desktop
         :config
         (progn
             (setq desktop-restore-frames nil)

             ;; use only one desktop
             (setq desktop-path (list user-emacs-directory))
             (setq desktop-dirname user-emacs-directory)
             (setq desktop-base-file-name "emacs-desktop")

             (defun ayrc/remove-stale-desktop-lock-file (dir)
                 (let ((pid (desktop-owner dir)))
                     (when pid
                         (let ((infile nil)
                               (destination nil)
                               (display nil))
                             (unless (= (call-process "ps" infile destination display "-p"
                                                      (number-to-string pid)) 0)
                                 (let ((lock-fn (desktop-full-lock-name dir)))
                                     (delete-file lock-fn)))))))

             ;; remove desktop after it's been read
             (add-hook 'desktop-after-read-hook
                       #'(lambda ()
                             ;; desktop-remove clears desktop-dirname
                             (setq desktop-dirname-tmp desktop-dirname)
                             (desktop-remove)
                             (setq desktop-dirname desktop-dirname-tmp)))

             (defun ayrc/path-to-saved-session ()
                 (file-exists-p
                  (concat desktop-dirname "/" desktop-base-file-name)))

             ;; use session-restore to restore the desktop manually
             (defun ayrc/session-restore ()
                 "Restore a saved emacs session."
                 (interactive)
                 (ayrc/remove-stale-desktop-lock-file desktop-dirname)
                 (if (ayrc/path-to-saved-session)
                         (desktop-read)
                     (message "No desktop found.")))

             ;; use session-save to save the desktop manually
             (defun ayrc/session-save ()
                 "Save an emacs session."
                 (interactive)
                 (if (ayrc/path-to-saved-session)
                         (if (y-or-n-p "Overwrite existing desktop? ")
                                 (desktop-save-in-desktop-dir)
                             (message "Session not saved."))
                     (desktop-save-in-desktop-dir)))))
    #+END_SRC

** [[https://github.com/purcell/exec-path-from-shell][Use user ${PATH} from shell]]
   Make Emacs use the $PATH set up by the user's shell

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
         :ensure t
         :config
         (progn
             (setq exec-path-from-shell-check-startup-files nil)

             (when (memq window-system '(mac ns x))
                 (exec-path-from-shell-initialize)
                 (exec-path-from-shell-copy-env "PYENV_ROOT"))))
   #+END_SRC
** Auto revert mode
   Revert buffers when files on disk change

   #+BEGIN_SRC emacs-lisp
     (use-package autorevert
         :diminish auto-revert-mode)
   #+END_SRC

** Abbrev mode
   Word abbreviations mode. In Abbrev mode, inserting an abbreviation causes
   it to expand and be replaced by its expansion

   #+BEGIN_SRC emacs-lisp
     (use-package abbrev
         :diminish abbrev-mode)
   #+END_SRC

** Line numbering
*** Left panel
    Interface for display-line-numbers

    #+BEGIN_SRC emacs-lisp
      (use-package display-line-numbers
	  :config
	  (progn
	      (setq display-line-numbers-width-start 5)))
    #+END_SRC

*** Modeline
    #+BEGIN_SRC emacs-lisp
      (line-number-mode t)
      (column-number-mode t)
    #+END_SRC

** [[http://www.dr-qubit.org/undo-tree/undo-tree.el][Undo tree]]                                                                               :hotkeys:
   Treat undo history as a tree

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
         :ensure t
         :bind (("C-x u" . undo-tree-visualize))
         :diminish undo-tree-mode
         :config
         (progn
             (global-undo-tree-mode)))
   #+END_SRC

** [[https://github.com/abo-abo/avy][Jump to things in Emacs tree-style]]                                                      :hotkeys:
   Jump to arbitrary positions in visible text and select text quickly

   #+BEGIN_SRC emacs-lisp
     (use-package avy
         :ensure t
         :bind (("C-;"     . avy-goto-char-2)
                ("C-'"     . avy-goto-line)
                ("M-g c"   . avy-goto-char)
                ("M-g e"   . avy-goto-word-0)
                ("M-g g"   . avy-goto-line)
                ("M-g w"   . avy-goto-word-1)
                ("M-g ("   . avy-goto-open-paren)
                ("M-g )"   . avy-goto-close-paren)
                ("M-g P"   . avy-pop-mark)
                ("M-g M-g" . avy-goto-line))
         :config
         (progn
             ;; case sensitive makes selection easier
             (setq avy-case-fold-search nil)

             (avy-setup-default)))
   #+END_SRC
** Current line hightlight
   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode 1)
   #+END_SRC

** Common clipboard with X Server
   #+BEGIN_SRC emacs-lisp
     (setq select-enable-clipboard t)
   #+END_SRC

** [[https://github.com/hbin/smart-shift][Region shifting]]
   Smart shift text left/right.

   #+BEGIN_SRC emacs-lisp
     (use-package smart-shift
       :ensure t
       :diminish smart-shift-mode
       :bind
       (:map smart-shift-mode-map
             ("<C-up>" . smart-shift-up)
             ("<C-down>" . smart-shift-down)
             ("<C-left>" . smart-shift-left)
             ("<C-right>" . smart-shift-right)))
   #+END_SRC

** Visual line mode
  #+BEGIN_SRC emacs-lisp
    (setq word-wrap t)
    (diminish 'visual-line-mode)
  #+END_SRC

** [[http://elpa.gnu.org/packages/adaptive-wrap.html][Automatic line wrapping]]
   This package provides the `adaptive-wrap-prefix-mode' minor mode which sets
   the wrap-prefix property on the fly so that single-long-line paragraphs get
   word-wrapped in a way similar to what you'd get with M-q using
   adaptive-fill-mode, but without actually changing the buffer's text.

   #+BEGIN_SRC emacs-lisp
     (use-package adaptive-wrap
         :ensure t
         :diminish adaptive-wrap-prefix-mode
         :hook (visual-line-mode . adaptive-wrap-prefix-mode)
         :commands (adaptive-wrap-prefix-mode)
         :config
         (progn
             (setq-default adaptive-wrap-extra-indent 2)))
   #+END_SRC

** Disable automatic line breaking
   When Auto Fill mode is enabled, inserting a space at a column
   beyond ‘current-fill-column’ automatically breaks the line at a
   previous space.

   This minor-mode have bad behavior almost in all modes.

   #+BEGIN_SRC emacs-lisp
     (diminish 'auto-fill-function)

     (auto-fill-mode            -1)
     (remove-hook 'text-mode-hook #'turn-on-auto-fill)
   #+END_SRC

** Delete Selection mode
   If you enable Delete Selection mode, a minor mode,
   then inserting text while the mark is active causes the selected text
   to be deleted first. This also deactivates the mark. Many graphical
   applications follow this convention, but Emacs does not.

   #+BEGIN_SRC emacs-lisp
     (delete-selection-mode t)
   #+END_SRC

** [[https://github.com/syohex/emacs-anzu][Display in the modeline search information]]                                              :hotkeys:
   Show number of matches in mode-line while searching

   #+BEGIN_SRC emacs-lisp
     (use-package anzu
         :ensure t
         :diminish anzu-mode
         :bind (([remap query-replace]        . #'anzu-query-replace)
                ([remap query-replace-regexp] . #'anzu-query-replace-regexp)

                :map isearch-mode-map
                ([remap isearch-query-replace]        . #'anzu-isearch-query-replace)
                ([remap isearch-query-replace-regexp] . #'anzu-isearch-query-replace-regexp))
         :init
         (progn
             (global-anzu-mode)))
   #+END_SRC

** [[https://github.com/lewang/ws-butler][Fixing up whitespaces only for touched lines]]
   Unobtrusively remove trailing whitespace

   #+BEGIN_SRC emacs-lisp
     (use-package ws-butler
         :diminish ws-butler-mode
         :ensure t
         :commands (ws-butler-mode))
   #+END_SRC

** Highlight expressions between {},[],()
   Highlight matching paren

   #+BEGIN_SRC emacs-lisp
     (use-package paren
       :config
       (progn
         (setq show-paren-delay 0)
         (setq show-paren-style 'expression)

         (show-paren-mode)))
   #+END_SRC

** [[https://github.com/Fuco1/smartparens][Automatically pairs braces and quotes]]
   Minor mode for Emacs that deals with parens pairs and tries to be smart
   about it

   #+BEGIN_SRC emacs-lisp
     (use-package smartparens
         :ensure t
         :diminish smartparens-mode "[SP]"
         :commands (smartparens-mode smartparens-strict-mode)
         :config
         (progn
             (sp-pair "'" "'" :actions nil)))
   #+END_SRC

** [[https://github.com/cosmicexplorer/helm-rg][Ripgrep]]                                                                 :helm:hotkeys:projectile:
   A helm interface to ripgrep

   #+BEGIN_SRC emacs-lisp
     (use-package helm-rg
         :ensure t
         :bind (("C-c h s" . helm-rg))
         :commands (helm-rg
                    helm-projectile-rg))
   #+END_SRC

** Set newline at the end of file
 #+BEGIN_SRC emacs-lisp
   (setq require-final-newline t)
   (setq next-line-add-newlines t)
 #+END_SRC

** Spell checking
   #+BEGIN_SRC emacs-lisp
     (use-package flyspell)
   #+END_SRC

** Outline mode
   #+BEGIN_SRC emacs-lisp
     (use-package outline
         :diminish outline-minor-mode "[o]"
         :bind (:map outline-minor-mode-map
                     ("C-c f TAB" . ayrc/outline-toggle-entry)
                     ("C-c f h"   . ayrc/outline-hide-all)
                     ("C-c f s"   . ayrc/outline-show-all))
         :config
         (defvar ayrc/outline-toggle-all-flag nil "toggle all flag")
         (make-variable-buffer-local 'ayrc/outline-toggle-all-flag)

         (defvar ayrc/cpos_save nil "current cursor position")
         (make-variable-buffer-local 'ayrc/cpos_save)

         (defun ayrc/outline-toggle-entry ()
             (interactive)
             "Toggle outline hiding for the entry under the cursor"
             (if (progn
                     (setq ayrc/cpos_save (point))
                     (end-of-line)
                     (get-char-property (point) 'invisible))
                     (progn
                         (outline-show-subtree)
                         (goto-char ayrc/cpos_save))
                 (progn
                     (outline-hide-subtree)
                     (goto-char ayrc/cpos_save))))

         (defun ayrc/outline-show-all ()
             (interactive)
             "Show all outline hidings for the entire file"
             (setq ayrc/outline-toggle-all-flag nil)
             (outline-show-all))

         (defun ayrc/outline-hide-all ()
             (interactive)
             "Hide all outline hidings for the entire file"
             (setq ayrc/outline-toggle-all-flag t)
             (outline-hide-sublevels 1))

         (defun ayrc/outline-toggle-all ()
             (interactive)
             "Toggle outline hiding for the entire file"
             (if ayrc/outline-toggle-all-flag
                     (ayrc/outline-show-all)
                 (ayrc/outline-hide-all))))
   #+END_SRC

** [[https://github.com/alpaker/fill-column-indicator][Fill column indicator]]
   Graphically indicate the fill column

   #+BEGIN_SRC emacs-lisp
     (use-package fill-column-indicator
         :ensure t
         :commands (fci-mode)
         :config
         (progn
             (setq fci-rule-column 79)))
   #+END_SRC

** Cleaning screen                                                                              :ui:
*** Disable welcom screen
    #+BEGIN_SRC emacs-lisp
      (setq inhibit-splash-screen   t)
      (setq inhibit-startup-message t)
    #+END_SRC

*** Disable dialog box
   #+BEGIN_SRC emacs-lisp
     (setq use-dialog-box nil)
   #+END_SRC

*** Disable indicators
    #+BEGIN_SRC emacs-lisp
      (setq-default indicate-empty-lines t)
      (setq-default indicate-buffer-boundaries 'left)
      (size-indication-mode nil) ;; Don't show current buffer size
    #+END_SRC

*** Disable cursor blink
    #+BEGIN_SRC emacs-lisp
      (blink-cursor-mode 0)
    #+END_SRC

*** Disable ring-bell-function
    That called when whenever function ‘ding’ is called.

    #+BEGIN_SRC emacs-lisp
      (setq ring-bell-function 'ignore)
    #+END_SRC

** Use 'y' and `n' instead of 'yes' and 'not'                                                   :ui:
   #+BEGIN_SRC emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** Fullscreen at GUI startup                                                                    :ui:
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'default-frame-alist '(fullscreen . maximized))
   #+END_SRC

** Name of current buffer in window title                                                       :ui:
   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format "GNU Emacs: %b")
   #+END_SRC

** Scroll settings                                                                              :ui:
   #+BEGIN_SRC emacs-lisp
     (setq scroll-preserve-screen-position t
           scroll-margin 0
           scroll-conservatively 101)

     (pixel-scroll-mode)

     ;; Never go back to the old scrolling behaviour.
     (setq pixel-dead-time 0)

     ;; Scroll by number of pixels instead of
     ;; lines (t = frame-char-height pixels).
     (setq pixel-resolution-fine-flag t)

     ;; Distance in pixel-resolution to scroll each mouse wheel event.
     (setq mouse-wheel-scroll-amount '(1))

     (setq mouse-wheel-progressive-speed nil)

     ;; No (less) lag while scrolling lots.
     (setq fast-but-imprecise-scrolling t)

     ;; Just don't even fontify if we're still catching up on user input.
     (setq jit-lock-defer-time 0)

     (global-set-key (kbd "M-n")
                     '(lambda nil (interactive) (pixel-scroll-up 1)))
     (global-set-key (kbd "M-p")
                     '(lambda nil (interactive) (pixel-scroll-down 1)))
   #+END_SRC

** [[https://github.com/domtronn/all-the-icons.el][Icons]]                                                                                        :ui:
   A library for inserting Developer icons

   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons
       :ensure t)
   #+END_SRC

** [[https://github.com/jaypei/emacs-neotree][NeoTree]]                                                                                      :ui:
   A tree plugin like NerdTree for Vim

   #+BEGIN_SRC emacs-lisp
     (use-package neotree
       :ensure t
       :bind ("<f1>" . neotree-toggle)
       :config
       (progn
         (setq neo-window-width 40)
         (setq neo-theme (if (display-graphic-p) 'icons 'arrow))))
   #+END_SRC

** [[https://emacs-helm.github.io/helm/][Helm]]                                                                            :helm:ui:hotkeys:
   Incremental and narrowing framework

   #+BEGIN_SRC emacs-lisp
     (use-package helm
         :ensure t
         :diminish helm-mode
         :bind
         (("M-x"       . helm-M-x)
          ("C-x C-b"   . helm-mini)
          ("C-x b"     . helm-mini)
          ("C-c h /"   . helm-find)
          ("C-c h h"   . helm-info)
          ("C-c h o"   . helm-occur)
          ("C-c h c"   . helm-semantic)
          ("C-c h i"   . helm-imenu)

          ;; Pre-configured helm to build regexps.
          ("C-c h r"   . helm-regexp)
          ("C-c h l"   . helm-bookmarks)
          ("C-c h a"   . helm-apropos)
          ("C-c h x"   . helm-register)
          ("C-c h m"   . helm-man-woman)
          ("C-x C-f"   . helm-find-files)
          ("M-y"       . helm-show-kill-ring)
          ;; make TAB work in terminal

          :map helm-map
          ;; rebind tab to do persistent action
          ("<tab>"     . helm-execute-persistent-action)
          ("C-i"       . helm-execute-persistent-action)
          ("C-z"       . helm-select-action))
         :init
         (progn
             (helm-mode 1))
         :config
         (progn
             (setq helm-M-x-fuzzy-match                  t
                   helm-mode-fuzzy-match                 t
                   helm-imenu-fuzzy-match                t
                   helm-locate-fuzzy-match               t
                   helm-apropos-fuzzy-match              t
                   helm-recentf-fuzzy-match              t
                   helm-semantic-fuzzy-match             t
                   helm-lisp-fuzzy-completion            t
                   helm-buffers-fuzzy-matching           t
                   helm-ff-search-library-in-sexp        t
                   helm-ff-file-name-history-use-recentf t
                   helm-completion-in-region-fuzzy-match t

                   ;; Open helm buffer inside current window, not occupy whole
                   ;; other window
                   helm-split-window-in-side-p           t

                   ;; Move to end or beginning of source when reaching top or
                   ;; bottom of source.
                   helm-move-to-line-cycle-in-source     nil

                   ;; Scroll 8 lines other window using M-<next>/M-<prior>
                   helm-scroll-amount                    8

                   helm-ff-file-name-history-use-recentf t)

             ;; Autoresize helm minibufer
             (helm-autoresize-mode t)))
   #+END_SRC

** Hotkeys for changing size of buffers                                                    :hotkeys:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "<C-M-up>") 'shrink-window)
     (global-set-key (kbd "<C-M-down>") 'enlarge-window)
     (global-set-key (kbd "<C-M-left>") 'shrink-window-horizontally)
     (global-set-key (kbd "<C-M-right>") 'enlarge-window-horizontally)
   #+END_SRC

** [[https://github.com/abo-abo/hydra][Hydra]]                                                                                   :hotkeys:
   Make bindings that stick around

   #+BEGIN_SRC emacs-lisp
     (use-package hydra
         :ensure t)
   #+END_SRC

** Layout switching                                                                        :hotkeys:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "<AltGr>") 'toggle-input-method)
   #+END_SRC
** Movement between windows with M-arrow-keys (except org-mode)                            :hotkeys:
    #+BEGIN_SRC emacs-lisp
     (if (equal nil (equal major-mode 'org-mode))
         (windmove-default-keybindings 'meta))
    #+END_SRC

** Delete many spaces as mash in tab
    #+BEGIN_SRC emacs-lisp
      ;; (defun ayrc/backward-delete-tab-whitespace ()
      ;;     "Delete many spaces as mash in tab."
      ;;     (interactive)
      ;;     (let ((p (point)))
      ;;         (cond
      ;;          ((and (eq indent-tabs-mode nil)
      ;;                (>= p tab-width)
      ;;                (eq (% (current-column) tab-width) 0)
      ;;                (string-match "^\\s-+$"
      ;;                              (buffer-substring-no-properties (- p tab-width) p)))
      ;;           (delete-char (- 0 tab-width)))
      ;;          (mark-active (delete-region (mark) p))
      ;;          (t (delete-char -1)))))

      ;; (global-set-key (kbd "<backspace>") 'ayrc/backward-delete-tab-whitespace)
    #+END_SRC

** Add newline and indent on enter press                                                   :hotkeys:
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "RET") 'newline-and-indent)
  #+END_SRC

** Scroll screen without changing cursor position                                          :hotkeys:
  #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "M-n") (lambda () (interactive) (scroll-up 1)))
   (global-set-key (kbd "M-p") (lambda () (interactive) (scroll-down 1)))
  #+END_SRC

** Revert buffer                                                                           :hotkeys:
  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "<f5>") (lambda () (interactive) (revert-buffer)))
  #+END_SRC
** [[https://github.com/bbatsov/projectile][Project managment]]                    :helm:projectile:
   #+BEGIN_SRC emacs-lisp :noweb tangle
     (use-package projectile
         :ensure t
         :delight '(:eval (format "[P<%s>]" (projectile-project-name)))
         :bind (:map projectile-mode-map
                     ("<f9>"    . projectile-compile-project)
                     ("C-x p o" . projectile-switch-open-project)
                     ("C-x p s" . projectile-switch-project)
                     ("C-c p i" . projectile-invalidate-cache)
                     ("C-c p z" . projectile-cache-current-file))
         :init
         (progn
             <<helm-projectile-use-package>>

             (projectile-mode 1))
         :config
         (progn
             (setq projectile-completion-system 'helm)
             (setq projectile-switch-project-action 'helm-projectile)

             (setq projectile-project-root-files-top-down-recurring
                   (append
                    '("compile_commands.json"
                      ".cquery"
                      ".ccls")
                    projectile-project-root-files-top-down-recurring))))
   #+END_SRC

*** [[https://github.com/bbatsov/helm-projectile][Helm]]
     #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref helm-projectile-use-package
       (use-package helm-projectile
           :ensure t
           :after projectile
           :bind (:map projectile-mode-map
                       ("C-c p s" . ayrc/helm-projectile-grep-or-rg)
                       ("C-c p h" . helm-projectile)
                       ("C-c p p" . helm-projectile-switch-project)
                       ("C-c p f" . helm-projectile-find-file)
                       ("C-c p F" . helm-projectile-find-file-in-known-projects)
                       ("C-c p g" . helm-projectile-find-file-dwim)
                       ("C-c p d" . helm-projectile-find-dir)
                       ("C-c p e" . helm-projectile-recentf)
                       ("C-c p a" . helm-projectile-find-other-file)
                       ("C-c p b" . helm-projectile-switch-to-buffer))
           :preface
           (progn
               (defun ayrc/helm-projectile-grep-or-rg ()
                   "Uses helm-projectile-grep, if ag doesn't present"
                   (interactive)
                   (if (executable-find "rg") (helm-projectile-rg)
                       (helm-projectile-grep)))))

     #+END_SRC

** Static code analysis
*** Flymake
    A universal on-the-fly syntax checker

    #+BEGIN_SRC emacs-lisp :noweb tangle
      (use-package flymake
          :diminish flymake-mode "[FM]"
          :commands (flymake-mode)
          :init
          (progn
              <<helm-flymake-use-package>>))
    #+END_SRC

**** [[https://github.com/tam17aki/helm-flymake][Helm]]
     #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref helm-flymake-use-package
       (use-package helm-flymake
           :ensure t
           :bind (:map flymake-mode-map
                       ("C-c h f" . helm-flymake))
           :commands (helm-flymake))
     #+END_SRC

*** [[http://www.flycheck.org][Flycheck]]
    On-the-fly syntax checking

    #+BEGIN_SRC emacs-lisp :noweb tangle
      (use-package flycheck
          :ensure t
          :diminish flycheck-mode "[FC]"
          :commands (flycheck-mode)
          :hook (flycheck-mode . ayrc/flycheck-hook)
          :init
          (progn
              <<helm-flycheck-use-package>>)
          :preface
          (progn
              <<flycheck-hook>>))
    #+END_SRC

**** [[https://github.com/yasuyk/helm-flycheck][Helm]]
     #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref helm-flycheck-use-package
       (use-package helm-flycheck
           :ensure t
           :after flycheck
           :bind (:map flycheck-mode-map
                       ("C-c h f" . helm-flycheck))
           :commands (helm-flycheck))
     #+END_SRC

**** Hook
     #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref flycheck-hook
       (defun ayrc/flycheck-hook ()
           (flymake-mode -1)

           (setq flycheck-checker-error-threshold 700)
           (setq flycheck-standard-error-navigation nil)
           (setq flycheck-idle-change-delay 0)
           (setq flycheck-check-syntax-automatically '(save mode-enabled)))
     #+END_SRC

** Autocompletion
*** Semantic
    #+BEGIN_SRC emacs-lisp
      (use-package semantic
          :diminish semantic-mode "[S]"
          :commands (semantic-mode))
    #+END_SRC

*** [[http://company-mode.github.io/][Company]]
    #+BEGIN_SRC emacs-lisp :noweb tangle
      (use-package company
          :ensure t
          :diminish company-mode
          :bind
          (:map company-active-map
                ("<tab>" . company-complete-selection))
          :hook (company-mode . ayrc/company-hook)
          :init
          (progn
              <<company-box-use-package>>
              <<company-flx-use-package>>
              <<company-quickhelp-use-package>>)
          :preface
          (progn
              <<company-hook>>))
    #+END_SRC

**** [[https://www.github.com/expez/company-quickhelp][Documentation]]
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref company-quickhelp-use-package
      (use-package company-quickhelp
          :ensure t
          :after company
          :hook (company-mode . company-quickhelp-mode)
          :bind (:map company-active-map
                      ("M-h" . #'company-quickhelp-manual-begin)))
    #+END_SRC

**** [[https://github.com/PythonNut/company-flx][Fuzzy matching]]
     #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref company-flx-use-package
       (use-package company-flx
           :ensure t
           :after company
           :hook (company-mode . company-flx-mode))
     #+END_SRC

**** [[https://github.com/sebastiencs/company-box][Icons]]
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref company-box-use-package
      (use-package company-box
          :ensure t
          :disabled
          :after company
          :hook (company-mode . company-box-mode)
          :config
          (progn
              (setq company-box-icons-alist company-box-icons-all-the-icons)))
     #+END_SRC

**** Hook
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref company-hook
      (defun ayrc/company-hook ()
          (setq company-tooltip-align-annotations t

                ;; Easy navigation to candidates with M-<n>
                company-idle-delay                0.0

                company-show-numbers              t
                company-minimum-prefix-length     1)

          (setq company-backends
                ;; files & directory && keywords
                '((company-files        company-keywords)
                  ;; abbreviations && dynamic abbreviat
                  (company-abbrev     company-dabbrev))))
    #+END_SRC

** Folding
   #+BEGIN_SRC emacs-lisp
     (use-package hideshow
         :diminish hs-minor-mode
         :commands (hs-minor-mode)
         :bind
         (:map hs-minor-mode-map
               ("C-c f TAB" . hs-toggle-hiding)
               ("C-c f h"   . hs-hide-all)
               ("C-c f s"   . hs-show-all))
         :init
         (progn
             ;; For yaml mode and others
             (defun ayrc/indenation-toggle-fold ()
                 "Toggle fold all lines larger than indentation on current line"
                 (interactive)
                 (let ((col 1))
                     (save-excursion
                         (back-to-indentation)
                         (setq col (+ 1 (current-column)))
                         (set-selective-display
                          (if selective-display nil (or col 1)))))))
         :config
         (progn
             (add-to-list 'hs-special-modes-alist
                          (list 'nxml-mode
                                "<!--\\|<[^/>]*[^/]>"
                                "-->\\|</[^/>]*[^/]>"
                                "<!--"
                                'nxml-forward-element
                                nil))))
   #+END_SRC
** [[http://github.com/joaotavora/yasnippet][FSnippets]]
   #+BEGIN_SRC emacs-lisp :noweb tangle
     (use-package yasnippet
         :ensure t
         :diminish yas-minor-mode
         :init
         (progn
             <<snippets-collection>>)
         :config
         (progn
             (setq yas-snippet-dirs
                   (list
                    yasnippet-snippets-dir
                    (ayrc/expand-config-path "./personal-snippets") ;; Personal snippets
                    ))
             (yas-reload-all)))
   #+END_SRC

*** [[https://github.com/AndreaCrotti/yasnippet-snippets][Ready snippets collection]]
    A collection of yasnippet snippets for many languages

    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref snippets-collection
      (use-package yasnippet-snippets
          :ensure t
          :after yasnippet)
    #+END_SRC

** Indents
   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 4)
     (setq-default pc-basic-offset 4)
     (setq-default standart-indent 4)
     (setq-default indent-tabs-mode nil)
   #+END_SRC

*** [[https://github.com/Malabarba/aggressive-indent-mode][Aggressive Indent]]
    Emacs minor mode that keeps your code always indented.
    More reliable than electric-indent-mode.

    #+BEGIN_SRC emacs-lisp :noweb tangle
      (use-package aggressive-indent
          :ensure t
          :commands (aggressive-indent-mode)
          :hook (aggressive-indent-mode . ayrc/aggressive-indent-hook)
          :diminish aggressive-indent-mode "[a]"
          :preface
          (progn
              <<aggressive-indent-hook>>))
    #+END_SRC

**** Hook
     #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref aggressive-indent-hook
       (defun ayrc/aggressive-indent-hook ()
           (electric-indent-local-mode -1))
     #+END_SRC

** Highlighting
*** Syntax
    #+BEGIN_SRC emacs-lisp
      (use-package font-lock
        :config
        (progn
          (setq font-lock-maximum-decoration t)))
    #+END_SRC

*** [[https://github.com/antonj/Highlight-Indentation-for-Emacs][Indentation]]
    Minor modes for highlighting indentation

    #+BEGIN_SRC emacs-lisp
      (use-package highlight-indentation
        :ensure t
        :diminish "[hi]"
        :commands (highlight-indentation-mode))
    #+END_SRC

** [[https://github.com/editorconfig/editorconfig-emacs][EditorConfig]]
   #+BEGIN_SRC emacs-lisp
     (use-package editorconfig
       :ensure t
       :diminish "[ec]"
       :config
       (progn
         (editorconfig-mode)))
   #+END_SRC

** [[https://github.com/magnars/expand-region.el][Expand region]]                          :hotkeys:
   #+BEGIN_SRC emacs-lisp
     (use-package expand-region
       :ensure t
       :commands (er/expand-region)
       :bind ("C-=" . er/expand-region))
   #+END_SRC

** Eldoc
   #+BEGIN_SRC emacs-lisp
     (use-package eldoc
         :diminish eldoc-mode
         :init
         (progn
             (global-eldoc-mode -1)))
   #+END_SRC

** [[https://github.com/leoliu/ggtags][GTags]]
   Emacs frontend to GNU Global source code tagging system

   #+NAME: gtags-system-prerequisites
   #+CAPTION: System prerequisites for GTags
   - [[https://www.gnu.org/software/global/][GNU Global]] :: intall it and put [[file:~/.emacs.d/other/etc/gtags.conf][gtags configuration]] into HOME/.globalrc
                   or gtags.conf into project root

   #+BEGIN_SRC emacs-lisp :noweb tangle
     (use-package ggtags
         :ensure t
         :diminish ggtags-mode "[G]"
         :commands (ggtags-mode)
         :init
         (progn
             <<helm-gtags-use-package>>)
         :config
         (progn
             (setq ggtags-update-on-save nil)
             (setq ggtags-use-idutils t)
             (setq ggtags-sort-by-nearness t)
             (unbind-key "M-<" ggtags-mode-map)
             (unbind-key "M->" ggtags-mode-map)))
   #+END_SRC

*** [[https://github.com/syohex/emacs-helm-gtags][Helm]]
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref helm-gtags-use-package
      (use-package helm-gtags
          :ensure t
          :after ggtags
          :commands (helm-gtags-select helm-gtags-find-tag)
          :config
          (progn
              (setq helm-gtags-fuzzy-match t)
              (setq helm-gtags-preselect t)
              (setq helm-gtags-prefix-key "\C-cg")
              (setq helm-gtags-path-style 'relative)

              (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
              (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)))
    #+END_SRC

** [[https://github.com/emacs-lsp/lsp-mode][LSP]]
   Emacs client/library for the Language Server Protocol

   #+BEGIN_SRC emacs-lisp :noweb tangle
     (use-package lsp-mode
         :ensure t
         :diminish lsp-mode "[L]"
         :commands (lsp-mode lsp-deffered lsp-rename)
         :hook (lsp-mode . ayrc/lsp-hook)
         :init
         (progn
             <<company-lsp-use-package>>
             <<lsp-ui-use-package>>
             <<helm-lsp-use-package>>)
         :config
         (progn
             <<redefined--lsp-auto-configure>>
             <<lsp-hook>>))
   #+END_SRC

*** Redefined lsp--auto-configure
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref redefined--lsp-auto-configure
      (defun lsp--auto-configure ()
          "Autoconfigure `company', `flycheck', `lsp-ui',  if they are installed."

          (when (functionp 'lsp-ui-mode)
              (lsp-ui-mode))

          (cond
           ((or
             (and (eq lsp-diagnostic-package :auto)
                  (functionp 'flycheck-mode))
             (and (eq lsp-diagnostic-package :flycheck)
                  (or (functionp 'flycheck-mode)
                      (user-error
                       "lsp-diagnostic-package is set to :flycheck but flycheck is not installed?")))
             ;; legacy
             (null lsp-diagnostic-package))
            (lsp-flycheck-enable))
           ((and (not (version< emacs-version "26.1"))
                 (or (eq lsp-diagnostic-package :auto)
                     (eq lsp-diagnostic-package :flymake)
                     (eq lsp-diagnostic-package t)))
            (with-no-warnings
                (require 'flymake)
                (lsp--flymake-setup)))
           ((not (eq lsp-diagnostic-package :none))
            (lsp--warn "Unable to autoconfigure flycheck/flymake. The diagnostics won't be rendered.")))

          (cond
           ((and (functionp 'company-lsp)
                 (not lsp-prefer-capf))
            (progn
                (company-mode 1)
                (add-to-list 'company-backends '(company-lsp :with company-yasnippet))
                (setq-local company-backends (remove 'company-capf company-backends))))

           ((and (fboundp 'company-mode))
            (company-mode 1)
            (add-to-list 'company-backends 'company-capf))))
    #+END_SRC

*** Hook
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref lsp-hook
      (defun ayrc/lsp-hook ()
          (setq lsp-prefer-flymake                         nil
                lsp-enable-folding                         t
                lsp-enable-snippet                         t
                lsp-vetur-completion-use-scaffold-snippets t
                lsp-enable-indentation                     t
                lsp-enable-file-watchers                   nil)

          (ayrc/local-set-keys '(("C-c r"   . lsp-rename)
                                 ("C-c C-r" . lsp-format-region)
                                 ("M-."     . lsp-ui-peek-find-definitions)
                                 ("M-,"     . xref-pop-marker-stack)
                                 ("M-?"     . lsp-ui-peek-find-references)
                                 ("C-M-."   . xref-find-apropos)))

          (flycheck-mode 1)

          (company-mode  1)
          (make-local-variable 'company-backends)

          (dap-mode      1))
    #+END_SRC

*** [[https://github.com/yyoncho/helm-lsp][Helm]]
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref helm-lsp-use-package
      (use-package helm-lsp
          :ensure t
          :bind
          ((:map lsp-mode-map
                 ("C-c h w" . helm-lsp-workspace-symbol)))
          :commands (helm-lsp-workspace-symbol))
    #+END_SRC

*** [[https://github.com/tigersoldier/company-lsp][Company]]
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref company-lsp-use-package
      (use-package company-lsp
          :ensure t
          :config
          (progn
              (setq
               company-lsp-enable-snippet      t
               company-transformers            nil
               company-lsp-async               t
               company-lsp-cache-candidates    nil

               company-lsp-enable-recompletion t)))
    #+END_SRC

*** [[https://github.com/emacs-lsp/lsp-ui][UI modules]]
    #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref lsp-ui-use-package
      (use-package lsp-ui
          :ensure t
          :hook (lsp-mode . lsp-ui-mode)
          :config
          (progn
              (setq lsp-ui-peek-enable           nil
                    lsp-ui-sideline-enable       nil
                    lsp-ui-imenu-enable          t
                    lsp-ui-doc-enable            t
                    lsp-ui-flycheck-enable       t
                    lsp-ui-doc-include-signature nil
                    lsp-ui-sideline-show-symbol  nil)))
    #+END_SRC

** Xref
   Cross-referencing commands

   #+BEGIN_SRC emacs-lisp :noweb tangle
     (use-package xref
         :init
         (progn
             <<helm-xref-use-package>>))
   #+END_SRC

*** [[https://github.com/brotzeit/helm-xref][Helm]]
     #+BEGIN_SRC emacs-lisp  :tangle no :noweb-ref helm-xref-use-package
       (use-package helm-xref
           :ensure t
           :commands (helm-xref-show-xrefs)
           :config
           (progn
               (if (< emacs-major-version 27)
                       (setq xref-show-xrefs-function 'helm-xref-show-xrefs)
                   (setq
                    xref-show-xrefs-function 'helm-xref-show-xrefs-27
                    xref-show-definitions-function 'helm-xref-show-defs-27))))
     #+END_SRC

** Debugging
*** [[http://github.com/realgud/realgud/][GUD]]
    #+BEGIN_SRC emacs-lisp
      (use-package realgud
          :ensure t
          :defer t)
    #+END_SRC

*** [[https://github.com/yyoncho/dap-mode][DAP]]
    Debug Adapter Protocol mode

    #+BEGIN_SRC emacs-lisp
      (use-package dap-mode
          :ensure t
          :diminish dap-mode "[D]"
          :hook (dap-mode . ayrc/dap-hook)
          :config
          (progn
              (defun ayrc/dap-hook ()
                  (setq dap-lldb-debug-program '("/usr/bin/lldb-vscode"))
                  (add-hook 'dap-stopped-hook
                            (lambda (arg) (call-interactively #'dap-hydra)))

                  ;; use tooltips for mouse hover
                  ;; if it is not enabled `dap-mode' will use the minibuffer.
                  (tooltip-mode 1)

                  (dap-ui-mode 1)

                  ;; enables mouse hover support
                  (dap-tooltip-mode 1)))
          :preface
          (progn
              (defun ayrc/dap-remove-nth-first-templates (count)
                  "For removing useless dap templates after loading of
                  language specific dap parts"
                  (setq dap-debug-template-configurations
                        (progn
                            (let ((rest-of-debug-templates
                                   (nthcdr
                                    count
                                    dap-debug-template-configurations)))
                                (if (listp rest-of-debug-templates)
                                        '()
                                    rest-of-debug-templates)))))))
    #+END_SRC

** Compilation
*** Press to compile                                                                       :hotkeys:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "<f9>") 'compile)
   #+END_SRC

*** Errors switching                                                                       :hotkeys:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "<f7>") 'next-error)
     (global-set-key (kbd "<f8>") 'previous-error)
   #+END_SRC

* Helpful functions
** Rename current buffer and file                                                      :interactive:
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/rename-current-file-and-buffer ()
       "Rename the current buffer and file it is visiting."
       (interactive)
       (let ((filename (buffer-file-name)))
         (if (not (and filename (file-exists-p filename)))
             (message "Buffer is not visiting a file!")
           (let ((new-name (read-file-name "New name: " filename)))
             (cond
              ((vc-backend filename) (vc-rename-file filename new-name))
              (t
               (rename-file filename new-name t)
               (set-visited-file-name new-name t t)))))))
   #+END_SRC

** Edit files as root                                                                  :interactive:
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/sudo-edit (&optional arg)
       "Edit currently visited file as root.

     With a prefix ARG prompt for a file to visit.
     Will also prompt for a file to visit if current
     buffer is not visiting a file."
       (interactive "P")
       (if (or arg (not buffer-file-name))
           (find-file (concat "/sudo:root@localhost:"
                              (ido-read-file-name "Find file(as root): ")))
         (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

   #+END_SRC

** Copy the current buffer file name to the clipboard                                  :interactive:
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/copy-file-name-to-clipboard ()
       "Copy the current buffer file name to the clipboard."
       (interactive)
       (let ((filename (if (equal major-mode 'dired-mode)
                           default-directory
                         (buffer-file-name))))
         (when filename
           (kill-new filename)
           (message "Copied buffer file name '%s' to the clipboard." filename))))
   #+END_SRC

** CRLF to LF                                                                          :interactive:
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/dos2unix (buffer)
       "Automate M-% C-q C-m RET C-q C-j RET"
       (interactive "*b")
       (save-excursion
         (goto-char (point-min))
         (while (search-forward (string ?\C-m) nil t)
           (replace-match (string ?\C-j) nil t))))
   #+END_SRC

** Copy hooks
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/copy-hooks-to (from-hook to-hook)
       (dolist (hook from-hook)
         (add-hook to-hook hook)))
   #+END_SRC

** Find path to executable
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/executable-find (command)
         "Search for COMMAND in `exec-path' and return the absolute file name.
     Return nil if COMMAND is not found anywhere in `exec-path'."
         ;; Use 1 rather than file-executable-p to better match the behavior of
         ;; call-process.
         (locate-file command exec-path exec-suffixes 1))
   #+END_SRC

** Set multiple local bindings
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/local-set-keys (key-commands)
         "Set multiple local bindings with KEY-COMMANDS list."
         (let ((local-map (current-local-map)))
             (dolist (kc key-commands)
                 (define-key local-map
                     (kbd (car kc))
                     (cdr kc)))))
   #+END_SRC

** Functions for making text pretty                                                    :interactive:
   #+BEGIN_SRC emacs-lisp
     (defun ayrc/tabify-buffer ()
         "Replace spaces by from buffer."
         (interactive)
         (tabify (point-min) (point-max)))

     (defun ayrc/untabify-buffer ()
         "Remove tabs from buffer."
         (interactive)
         (untabify (point-min) (point-max)))

     (defun ayrc/indent-buffer ()
       "Indent region."
       (interactive)
       (indent-region (point-min) (point-max)))

     (defun ayrc/cleanup-buffer-notabs ()
       "Perform a bunch of operations on the whitespace content of a buffer.
     Remove tabs."
       (interactive)
       (ayrc/indent-buffer)
       (ayrc/untabify-buffer)
       (delete-trailing-whitespace)
       nil)

     (defun ayrc/cleanup-buffer-tabs ()
         "Perform a bunch of operations on the whitespace content of a buffer.
     Dont remove tabs."
         (interactive)
         (ayrc/indent-buffer)
         (delete-trailing-whitespace)
         nil)
   #+END_SRC

* Org-mode
    #+BEGIN_SRC emacs-lisp :noweb tangle
      (use-package org
          :init
          (progn
              <<org-bullets-use-package>>
              <<org-present-use-package>>
              <<org-cliplink-use-package>>)
          :config
          (progn
              (defun ayrc/orgmode-hook()
                  (display-line-numbers-mode 1)
                  (visual-line-mode          1)
                  (ws-butler-mode            1)
                  (smartparens-mode          1)
                  (semantic-mode             1)
                  (yas-minor-mode            1)
                  (company-mode              1))
              (add-hook 'org-mode-hook 'ayrc/orgmode-hook)

              (setq org-log-done 'time)
              (setq org-src-tab-acts-natively t)
              (setq org-tags-column -100)

              (setq org-todo-keywords
                    '((sequence "TODO" "CURRENT" "|" "DONE" "CANCELED")))
              (setq org-todo-keyword-faces
                    '(("CURRENT" . "yellow")
                      ("CANCELED" . (:foreground "RoyalBlue3" :weight bold))))))
    #+END_SRC

** Bullets
** [[https://github.com/emacsorphanage/org-bullets][Bullets]]
   Show bullets in org-mode as UTF-8 characters

   #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-bullets-use-package
     (use-package org-bullets
         :ensure t
         :after org
         :commands org-bullets-mode
         :hook (org-mode . org-bullets-mode))
   #+END_SRC

** [[https://github.com/rlister/org-present][Present]]
   Minimalist presentation minor-mode for Emacs org-mode

   #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-present-use-package
     (use-package org-present
         :ensure t
         :after org
         :commands org-present)
   #+END_SRC

** [[http://github.com/rexim/org-cliplink][Cliplink]]
   Insert org-mode links from the clipboard

   #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-cliplink-use-package
     (use-package org-cliplink
         :ensure t
         :commands org-cliplink
         :bind (:map org-mode-map
                     ("C-c M-l" . org-cliplink)))
   #+END_SRC
